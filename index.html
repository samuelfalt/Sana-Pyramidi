<!doctype html>
<html lang="fi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sana pyramidi</title>
  <style>
    :root {
      --bg-start: #5fa8e0;
      --bg-end: #9be7ff;
      --panel: #e8f5ff;
      --tile: #d8ecff;
      --tile-border: rgba(12, 26, 44, 0.08);
      --tile-selected: #f08c00;
      --tile-selected-text: #0c1a2c;
      --tile-correct: #2ebf91;
      --tile-wrong: #d7263d;
      --text-main: #0c1a2c;
      --muted: #3f5a78;
      --shadow: 0 14px 40px rgba(12, 26, 44, 0.15);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 20% 25%, #cdeaff, #9be7ff 40%), linear-gradient(145deg, var(--bg-start), var(--bg-end));
      color: var(--text-main);
      font-family: "Trebuchet MS", "Futura", "Baskerville", sans-serif;
      padding: 40px 16px;
    }

    .card {
      width: min(1200px, 100%);
      background: var(--panel);
      border: 1px solid rgba(12, 26, 44, 0.08);
      border-radius: 18px;
      padding: 28px clamp(18px, 4vw, 36px) 32px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(4px);
    }

    header h1 {
      margin: 0 0 8px;
      font-family: "Baskerville", "Garamond", serif;
      font-size: clamp(30px, 3vw, 38px);
      letter-spacing: 0.5px;
    }

    header p {
      margin: 0 0 14px;
      color: var(--muted);
      line-height: 1.5;
    }

    .status-line {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 16px;
      color: var(--muted);
      font-size: 15px;
    }

    .status-line strong {
      color: var(--text-main);
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      border: none;
      cursor: pointer;
      font-weight: 700;
      padding: 12px 16px;
      border-radius: 12px;
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
      font-size: 15px;
    }

    .primary {
      background: linear-gradient(120deg, #f7c948, #f08c00);
      color: #0c1a2c;
      box-shadow: 0 10px 30px rgba(240, 140, 0, 0.25);
    }

    .secondary {
      background: rgba(255, 255, 255, 0.06);
      color: var(--text-main);
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 26px rgba(0, 0, 0, 0.2);
    }

    .pyramid {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .row {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 10px;
      align-items: center;
    }

    .hint {
      color: var(--muted);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      width: 130px;
      transition: color 160ms ease, opacity 160ms ease;
    }

    .hint.revealed {
      color: var(--text-main);
      opacity: 1;
    }

    .hint.hidden {
      opacity: 0.65;
    }

    .tiles {
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .tile {
      min-width: 100px;
      background: var(--tile);
      color: var(--text-main);
      border: 1px solid var(--tile-border);
      border-radius: 14px;
      padding: 12px 14px;
      text-align: center;
      letter-spacing: 0.2px;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease, color 120ms ease;
    }

    .tile:hover {
      transform: translateY(-2px);
      border-color: rgba(255, 255, 255, 0.18);
    }

    .tile.selected {
      background: var(--tile-selected);
      color: var(--tile-selected-text);
      border-color: rgba(12, 26, 44, 0.45);
      box-shadow: 0 10px 24px rgba(240, 140, 0, 0.25);
    }

    .tile.correct {
      background: var(--tile-correct);
      color: #0b2a1f;
      border-color: rgba(11, 42, 31, 0.4);
      box-shadow: 0 10px 26px rgba(46, 191, 145, 0.25);
    }

    .tile.wrong {
      background: var(--tile-wrong);
      color: #f7f1f2;
      border-color: rgba(0, 0, 0, 0.1);
      box-shadow: 0 10px 26px rgba(215, 38, 61, 0.3);
    }

    .tile.missed {
      outline: 1px dashed rgba(255, 255, 255, 0.25);
      outline-offset: 3px;
    }

    .tile.solved {
      opacity: 0.7;
      pointer-events: none;
    }

    .feedback {
      margin-top: 12px;
      font-weight: 700;
      color: var(--text-main);
    }

    @media (max-width: 700px) {
      .row {
        grid-template-columns: 1fr;
        justify-items: center;
      }

      .hint {
        text-align: center;
        width: auto;
      }

      .tiles {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="card">
    <header>
      <h1>Sana pyramidi</h1>
      <p>Valitse jokaiselta riviltä vihjeeseen sopivat sanat ja paina &quot;Tarkasta&quot;. Voit valita useita sanoja per rivi.</p>
      <div class="status-line">
        <span><strong>Valittuja:</strong> <span id="selected-count">0</span></span>
        <span><strong>Oikein:</strong> <span id="correct-count">0</span></span>
      </div>
      <div class="controls">
        <button class="primary" id="check-button" type="button">Tarkasta</button>
        <button class="secondary" id="reset-button" type="button">Tyhjennä</button>
      </div>
      <div id="feedback" class="feedback" aria-live="polite"></div>
    </header>

    <section id="pyramid" class="pyramid" aria-label="Sanapyramidi"></section>

  </div>

  <script>
    const puzzleData = [
      {
        hint: "Pink",
        correctWords: ["PINK"]
      },
      {
        hint: "Kurssi anagram",
        correctWords: ["COMS", "YMMA"]
      },
      {
        hint: "Kuumaa albumit",
        correctWords: ["KELTAINEN", "PUNAINEN", "SININEN"]
      },
      {
        hint: "Uinti tyylit",
        correctWords: ["SAMMAKKO", "KOIRA", "DELFIINI", "KISSA"]
      },
      {
        hint: "-mari",
        correctWords: ["UI", "TII", "KAL", "KAM", "TUO"]
      }
    ];

    const initialRows = [
      ["KAL"],
      ["DELFIINI", "PINK"],
      ["TUO", "SAMMAKKO", "SININEN"],
      ["COMS", "KISSA", "KAM", "PUNAINEN"],
      ["UI", "KELTAINEN", "KOIRA", "YMMA", "TII"]
    ];

    const levelOffsets = [0, 1, 3, 6, 10];
    const levelPositions = [
      [0],
      [1, 2],
      [3, 4, 5],
      [6, 7, 8, 9],
      [10, 11, 12, 13, 14]
    ];

    const positions = initialRows.flat(); // length 15
    const solvedPos = Array(15).fill(false);

    const pyramid = document.getElementById("pyramid");
    const feedback = document.getElementById("feedback");
    const selectedCountEl = document.getElementById("selected-count");
    const correctCountEl = document.getElementById("correct-count");
    const levelsContainer = document.getElementById("levels");

    const wordToCategory = new Map();
    puzzleData.forEach((cat, index) => {
      cat.correctCount = cat.correctWords.length;
      cat.solved = false;
      cat.correctWords.forEach(w => wordToCategory.set(w.toUpperCase(), index));
    });

    const totalCorrectWords = puzzleData.reduce((acc, row) => acc + row.correctCount, 0);
    const maxLevel = Math.max(...puzzleData.map(row => row.correctCount));
    const levelMap = new Map();
    const replacementIndex = Array.from({ length: maxLevel }, () => 0);
    let solvedWordCount = 0;

    function buildLevels() {
      levelsContainer.innerHTML = "";
      for (let i = 1; i <= maxLevel; i++) {
        const levelEl = document.createElement("div");
        levelEl.className = "level";
        levelEl.dataset.level = i;

        const label = document.createElement("div");
        label.className = "level-label";
        label.textContent = `Taso ${i}`;

        const wordsWrap = document.createElement("div");
        wordsWrap.className = "level-words";
        levelMap.set(i, wordsWrap);

        levelEl.appendChild(label);
        levelEl.appendChild(wordsWrap);
        levelsContainer.appendChild(levelEl);
      }
    }

    function buildPyramid() {
      pyramid.innerHTML = "";
      for (let rowIndex = 0; rowIndex < initialRows.length; rowIndex++) {
        const rowEl = document.createElement("div");
        rowEl.className = "row";

        const hint = document.createElement("div");
        hint.className = "hint hidden";
        const placeholder = `${rowIndex + 1}. ????`;
        hint.textContent = placeholder;
        hint.dataset.full = `${rowIndex + 1}. ${puzzleData[rowIndex].hint}`;
        hint.dataset.placeholder = placeholder;
        hint.id = `hint-${rowIndex}`;
        rowEl.appendChild(hint);

        const tiles = document.createElement("div");
        tiles.className = "tiles";

        const start = levelOffsets[rowIndex];
        const len = rowIndex + 1;
        for (let i = 0; i < len; i++) {
          const posIndex = start + i;
          const word = positions[posIndex];
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "tile";
          btn.textContent = word;
          btn.dataset.row = rowIndex;
          btn.dataset.index = i;
          btn.dataset.pos = posIndex;
          btn.dataset.label = word;
          btn.setAttribute("aria-pressed", "false");
          btn.addEventListener("click", () => toggleTile(btn, rowIndex, posIndex));
          tiles.appendChild(btn);
        }

        rowEl.appendChild(tiles);
        pyramid.appendChild(rowEl);
      }
    }

    function toggleTile(tile, rowIndex, posIndex) {
      if (puzzleData[rowIndex].solved || solvedPos[posIndex]) {
        return;
      }
      const selecting = !tile.classList.contains("selected");
      if (selecting && currentSelectedCount() >= 5) {
        feedback.textContent = "Voit valita enintään 5 sanaa kerrallaan.";
        return;
      }
      tile.classList.toggle("selected");
      tile.classList.remove("correct", "wrong", "missed");
      const isSelected = tile.classList.contains("selected");
      tile.setAttribute("aria-pressed", String(isSelected));
      feedback.textContent = "";
      updateSelectedCount();
    }

    function currentSelectedCount() {
      return pyramid.querySelectorAll(".tile.selected").length;
    }

    function updateSelectedCount() {
      selectedCountEl.textContent = currentSelectedCount();
    }

    function resetTiles() {
      pyramid.querySelectorAll(".tile").forEach(tile => {
        tile.classList.remove("selected", "correct", "wrong", "missed", "solved");
        tile.disabled = false;
        tile.setAttribute("aria-pressed", "false");
      });
      feedback.textContent = "";
      selectedCountEl.textContent = "0";
      correctCountEl.textContent = `${solvedWordCount}/${totalCorrectWords}`;
    }

    function revealHint(rowIndex) {
      const hint = document.getElementById(`hint-${rowIndex}`);
      if (!hint) return;
      hint.classList.remove("hidden");
      hint.classList.add("revealed");
      hint.textContent = hint.dataset.full;
    }

    function moveWordsToLevel(level, selectedTiles) {
      const container = levelMap.get(level);
      if (!container) return;
      selectedTiles.forEach(tile => {
        const bubble = document.createElement("div");
        bubble.className = "tile correct";
        bubble.textContent = tile.dataset.label.toUpperCase();
        container.appendChild(bubble);
      });
    }

    function refreshRow(rowIndex, lockSolved) {
      const buttons = Array.from(pyramid.querySelectorAll(`.tile[data-row="${rowIndex}"]`));
      const start = levelOffsets[rowIndex];
      buttons.forEach((btn, idx) => {
        const posIndex = start + idx;
        const word = positions[posIndex];
        btn.textContent = word;
        btn.dataset.label = word;
        btn.dataset.pos = posIndex;
        if (lockSolved || solvedPos[posIndex]) {
          btn.classList.remove("selected", "wrong", "missed");
          btn.classList.add("correct", "solved");
          btn.disabled = true;
          btn.setAttribute("aria-pressed", "false");
        } else {
          btn.classList.remove("selected", "correct", "wrong", "missed", "solved");
          btn.disabled = false;
          btn.setAttribute("aria-pressed", "false");
        }
      });
    }

    function swapWithLevelRow(level, selectedTiles) {
      const targetPositions = levelPositions[level - 1];
      if (!targetPositions) return;

      const selectedPos = selectedTiles.map(t => Number(t.dataset.pos));
      const count = Math.min(selectedPos.length, targetPositions.length);

      const selectedWords = selectedPos.map(p => positions[p]);
      const selectedSet = new Set(selectedWords);
      const nextPositions = positions.slice();
      const displaced = [];

      // Fill target positions with selected words, keeping already-correct words in place
      const remainingSelected = [...selectedWords];
      targetPositions.forEach((posIdx, i) => {
        if (i >= count) return;
        const currentWord = positions[posIdx];
        if (selectedSet.has(currentWord)) {
          // keep it here, consume from remainingSelected
          const rm = remainingSelected.indexOf(currentWord);
          if (rm !== -1) remainingSelected.splice(rm, 1);
          nextPositions[posIdx] = currentWord;
        } else {
          const newWord = remainingSelected.shift();
          displaced.push(currentWord);
          nextPositions[posIdx] = newWord;
        }
        solvedPos[posIdx] = true;
      });

      // Move displaced words back into the original selected positions (outside target)
      let dispIndex = 0;
      selectedPos.forEach(posIdx => {
        if (targetPositions.includes(posIdx)) {
          return;
        }
        const newWord = displaced[dispIndex++];
        nextPositions[posIdx] = newWord;
        solvedPos[posIdx] = false;
      });

      positions.splice(0, positions.length, ...nextPositions);

      // refresh affected rows
      const rowsToRefresh = new Set([...selectedPos, ...targetPositions].map(posToRow));
      rowsToRefresh.forEach(r => refreshRow(r, false));
    }

    function checkAnswers() {
      const selectedTiles = Array.from(pyramid.querySelectorAll(".tile.selected"));
      if (selectedTiles.length === 0) {
        feedback.textContent = "Valitse ensin sanat ja yritä uudelleen.";
        return;
      }

      const selectedLabels = selectedTiles.map(t => t.dataset.label.toUpperCase());
      let solvedCategoryIndex = null;

      puzzleData.forEach((cat, idx) => {
        if (cat.solved || solvedCategoryIndex !== null) return;
        const catSet = new Set(cat.correctWords);
        const selSet = new Set(selectedLabels);
        const matchSize = selSet.size === catSet.size;
        const exactMatch = matchSize && [...selSet].every(lbl => catSet.has(lbl));
        if (exactMatch) {
          solvedCategoryIndex = idx;
        }
      });

      if (solvedCategoryIndex === null) {
        // wrong guess: clear selections back to base color
        selectedTiles.forEach(tile => {
          tile.classList.remove("selected", "correct");
          tile.setAttribute("aria-pressed", "false");
        });
        feedback.textContent = "Ei aivan – valinta ei vastaa mitään kategoriaa.";
        updateSelectedCount();
        return;
      }

      const cat = puzzleData[solvedCategoryIndex];
      cat.solved = true;
      solvedWordCount += cat.correctCount;
      correctCountEl.textContent = `${solvedWordCount}/${totalCorrectWords}`;

      revealHint(solvedCategoryIndex);
      moveWordsToLevel(cat.correctWords.length, selectedTiles);
      swapWithLevelRow(cat.correctWords.length, selectedTiles);

      feedback.textContent = solvedWordCount === totalCorrectWords
        ? "Täydellistä! Kaikki valinnat olivat oikein."
        : "Kategoria ratkaistu – jatka seuraaviin.";
      updateSelectedCount();
    }

    function posToRow(posIndex) {
      for (let r = levelOffsets.length - 1; r >= 0; r--) {
        if (posIndex >= levelOffsets[r]) return r;
      }
      return 0;
    }

    document.getElementById("check-button").addEventListener("click", checkAnswers);
    document.getElementById("reset-button").addEventListener("click", resetTiles);

    buildLevels();
    buildPyramid();
    correctCountEl.textContent = `0/${totalCorrectWords}`;
  </script>
</body>
</html>
